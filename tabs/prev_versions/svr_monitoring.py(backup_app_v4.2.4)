"""
Monitoring Module – Version 3.0.3
=================================

Demo Real-Time Monitoring Logic for Power Cable Applications
------------------------------------------------------------

This module implements a DEMO real-time monitoring view for a power cable
(e.g. HV / HVDC), intended for partner demonstrations and backend-ready UI
prototyping.

The implementation is GENERIC and NON-UCY-SPECIFIC:
any partner working on power cables, energy assets or similar infrastructure
could adopt the same logic and data flow.


------------------------------------------------------------
HIGH-LEVEL DESIGN OVERVIEW
------------------------------------------------------------

This monitoring module follows a SCADA-like, deterministic architecture:

1. Synthetic data are generated continuously (demo mode).
2. Raw samples are persisted to CSV files (one per metric).
3. Data are NORMALIZED and CLEANED on READ, not on write.
4. Aggregation and windowing are applied on a clean, time-consistent series.
5. Plotly figures are rebuilt from scratch on every refresh.

The design explicitly avoids:
- timing race conditions
- duplicated timestamps
- visual artifacts (double bars / stacking)
- dependency on refresh jitter


------------------------------------------------------------
TIME HANDLING (CRITICAL DESIGN DECISION)
------------------------------------------------------------

Raw data generation may produce:
- zero, one, or multiple samples per second
- due to callback timing jitter or backend behavior

Key principles:

- CSV timestamps have second-level resolution (HH:MM:SS).
- Multiple raw samples may exist for the same second.
- These raw samples are NOT plotted directly.

Normalization logic enforces:

1) Collapse all samples that fall in the SAME SECOND:
       → mean(value) per second
2) Resample to a STRICT 1-second grid:
       → resample("1S")
3) Forward-fill missing seconds:
       → ffill()

Result:
- EXACTLY one value per second
- No gaps
- No duplicated timestamps

This step is mandatory and prevents all known bar duplication artifacts.


------------------------------------------------------------
AGGREGATION LOGIC (1s / 2s / 5s)
------------------------------------------------------------

Aggregation is always applied AFTER per-second normalization.

Pipeline:

    Raw CSV
      → per-second mean
      → strict 1-second grid (resample + ffill)
      → OPTIONAL aggregation (2s / 5s windows)
      → tail(WINDOW_SIZE)
      → visualization

Important:
- Aggregation is TIME-BASED, not row-count-based.
- Refresh rate controls how often new samples are generated,
  NOT the correctness of aggregation.


------------------------------------------------------------
DATA PERSISTENCE (DEMO MODE)
------------------------------------------------------------

- Data are stored in CSV files (e.g. load, temperature).
- CSVs act as RAW INPUT buffers, not presentation-ready datasets.
- CSV files may be reset on monitoring startup to avoid legacy artifacts.
- File size is kept small (rolling window).

Data integrity guarantees:
- No NaN / null values are written.
- All values are forced numeric.
- Invalid generated values are replaced by safe fallback values.


------------------------------------------------------------
LOAD & TEMPERATURE MODELS
------------------------------------------------------------

Load model:
- Hybrid stochastic model:
    • Normal operating fluctuations around a base load.
    • Occasional higher-load "stress" events.
- Rate limiting is applied to avoid unrealistic jumps.

Temperature model:
- Temperature is derived from load (thermal dependency).
- Higher load → higher temperature.
- Changes are smoothed using a stricter rate limit to simulate
  thermal inertia.


------------------------------------------------------------
PLOTTING & VISUALIZATION (PLOTLY)
------------------------------------------------------------

Strict plotting rules:

- FULL figure replacement on every update.
- Exactly ONE bar trace per graph.
- No incremental updates.
- No trace reuse.
- No extendData.

Plotly is treated as a pure renderer:
    "This figure fully describes the graph state right now."

This guarantees:
- no stacked bars
- no ghost bars
- stable behavior across refresh rates


------------------------------------------------------------
TIME AXIS DISPLAY RULES
------------------------------------------------------------

For readability:

- First visible sample → full HH:MM:SS
- Minute change → full HH:MM:SS
- Intermediate samples → seconds only

This preserves temporal context without clutter.


------------------------------------------------------------
UI & TAB STRUCTURE NOTES
------------------------------------------------------------

Monitoring & KPIs Tab – Flask Popup Version (with wrapper):

- Vertical submenus under tabs
- Open Toolbox        → /toolbox
- Import Data         → /import
- PMU Settings        → /coordinates
- Power cable image (PNG/JPG) instead of SVG
- Clickable PMU coordinates
- CSS isolation via monitoring-tab wrapper


------------------------------------------------------------
INTENDED USAGE & EXTENSIBILITY
------------------------------------------------------------

This module is DEMO-oriented but backend-ready.

Safe future extensions:
- Replace CSV reads with API calls (same normalization logic).
- Replace synthetic generators with real measurements.
- Add EMA / smoothing after normalization.
- Add alert thresholds and KPIs.

DO NOT:
- Plot raw CSV rows directly.
- Remove per-second normalization.
- Tie correctness to refresh timing.


------------------------------------------------------------
END OF DESIGN NOTES – Monitoring v3.0.3
------------------------------------------------------------
"""

"""
HVDC Operational Telemetry Validation & Alerting Tool (Service Tab)

Purpose (project-facing):
- Provides an operational, SCADA-like monitoring environment for HVDC cable
  systems, combining real-time telemetry visualization, data normalization,
  and KPI computation.
- Focuses on validation of measurement relevance, temporal consistency,
  and operational correctness of incoming data streams (e.g. PMU / SCADA).
- Supports early alerting and operator situational awareness by exposing
  clean, time-aligned signals and derived indicators.

Platform role:
- Acts as a bridge between WP4 monitoring concepts and platform-level
  operational usage, supporting WP5 validation and WP6 demonstration
  activities.
- Designed as an onboarding-ready tool, enabling gradual transition from
  synthetic/demo data to real field measurements without architectural changes.

Notes:
- This tool is not a workflow entry point, but a reusable operational
  capability provided by the platform.
"""
import dash
from dash import html, dcc, Input, Output, State
import plotly.graph_objects as go
import numpy as np
from logic.data import _synth_series, _indicator, _chart
from pathlib import Path
import pandas as pd
from datetime import datetime
from utils.paths import MONITORING_DIR

from tabs_core.menu_layout import menu_layout
from tabs_core.tab_menu_renderers import register_tab_menu_callbacks

TAB_META = {
    "id": "svc-hvdc-operational-monitoring",

    "label": "HVDC Operational Telemetry Validation & Alerting",

    "type": "service",
    "order": 200,

    # Core monitoring WP + strong validation / demo usage
    "workpackages": ["WP4", "WP5", "WP6"],

    # This tool spans monitoring, awareness, and performance assessment
    "categories": [
        "Monitoring & Analytics",
        "Cable System Awareness",
        "Cable Performance & Optimization"
    ],

    "subcategories": [],

    # Functions intentionally not defined yet
    # "functions": [],

    "version": "v0.3 (demo, backend-ready)",
    "status": "active"
}

TAB_PREFIX = "svc-hvdc-operational-monitoring"

TAB_MENU_META = {
    "default": "overview",
    "items": [
        {"id": "overview", "label": "Overview"},
        {"id": "kpis", "label": "KPIs"},
        {"id": "realtime", "label": "Real-Time"},
        {"id": "pmu", "label": "PMU"},
    ],
}

# -----------------------------------------------------------------------------
# CONSTANTS
# -----------------------------------------------------------------------------

CSV_PATHS = {
    "load": MONITORING_DIR / "ucy_load.csv",
    "temp": MONITORING_DIR / "ucy_temp.csv",
}
WINDOW_SIZE = 30  # number of bars shown

RANGES = {
    "load": {"min": 0, "max": 1200, "unit": "A"},
    "temp": {"min": 20, "max": 90, "unit": "°C"},
}

# -----------------------------------------------------------------------------
# HELPERS
# -----------------------------------------------------------------------------

def ensure_csv(metric):
    path = CSV_PATHS[metric]
    path.parent.mkdir(parents=True, exist_ok=True)

    if not path.exists():
        df = pd.DataFrame(columns=["timestamp", "value"])
        df.to_csv(path, index=False)   

def reset_csvs():
    for path in CSV_PATHS.values():
        path.parent.mkdir(parents=True, exist_ok=True)
        df = pd.DataFrame(columns=["timestamp", "value"])
        df.to_csv(path, index=False)
     
def generate_temp_from_load(current):
    """
    Thermal behaviour model:
    - High load  -> temperature increases
    - Medium    -> roughly stable
    - Low load  -> temperature decreases
    """
    r_load = RANGES["load"]
    r_temp = RANGES["temp"]

    # normalize load 0..1
    norm = current / r_load["max"] if r_load["max"] else 0

    # baseline operating temperature
    base = 55.0

    # dynamic adjustment (±15 °C)
    delta = (norm - 0.5) * 30.0

    temp = base + delta

    # clamp to physical limits
    return np.clip(temp, r_temp["min"], r_temp["max"])

def apply_rate_limit(prev, new, max_pct):
    if prev is None or prev == 0:
        return new
    max_delta = prev * max_pct
    return np.clip(new, prev - max_delta, prev + max_delta)

def generate_value(metric):
    r = RANGES[metric]

    if metric == "load":
        # base operating point
        base = 550

        # normal fluctuation
        normal = np.random.normal(500, 80)

        # occasional stress event (20% πιθανότητα)
        stress = 0
        if np.random.rand() < 0.2:
            stress = np.random.uniform(300, 400)

        value = base + normal + stress

        return np.clip(value, r["min"], r["max"])

    else:
        return np.random.uniform(r["min"], r["max"])


def load_data(metric, window_sec=1):
    ensure_csv(metric)
    path = CSV_PATHS[metric]

    df = pd.read_csv(path)

    if df.empty or "timestamp" not in df.columns or "value" not in df.columns:
        return pd.DataFrame(columns=["timestamp", "value"])

    # ------------------------------------------------------------------
    # Parse timestamp → datetime (assumes HH:MM:SS)
    # ------------------------------------------------------------------
    df = df.copy()
    df["dt"] = pd.to_datetime(df["timestamp"], format="%H:%M:%S", errors="coerce")
    df = df.dropna(subset=["dt", "value"])

    df["value"] = pd.to_numeric(df["value"], errors="coerce")
    df = df.dropna(subset=["value"])

    # ------------------------------------------------------------------
    # 1) Collapse multiple samples per second → MEAN
    # ------------------------------------------------------------------
    df = (
        df.groupby("dt", as_index=True)["value"]
        .mean()
        .to_frame()
    )

    # ------------------------------------------------------------------
    # 2) Resample to EXACT 1-second grid
    #    Missing seconds → forward-fill
    # ------------------------------------------------------------------
    df = df.resample("1s").ffill()

    # ------------------------------------------------------------------
    # 3) Optional aggregation (2 sec / 5 sec)
    # ------------------------------------------------------------------
    if window_sec > 1:
        df = (
            df.resample(f"{window_sec}s")
              .mean()
        )

    # ------------------------------------------------------------------
    # 4) Final formatting
    # ------------------------------------------------------------------
    df = df.tail(WINDOW_SIZE)
    df["timestamp"] = df.index.strftime("%H:%M:%S")
    df = df.reset_index(drop=True)[["timestamp", "value"]]

    return df


def append_data(metric, value):
    ensure_csv(metric)

    if value is None or not np.isfinite(value):
        if metric == "load":
            value = np.random.uniform(400, 700)
        else:
            value = np.random.uniform(
                RANGES["temp"]["min"],
                RANGES["temp"]["max"],
            )

    ts = datetime.now().strftime("%H:%M:%S")
    path = CSV_PATHS[metric]

    with open(path, "a") as f:
        f.write(f"{ts},{float(value)}\n")


def build_figure(df, metric):
    """
    Build a CLEAN bar chart figure.
    - Always returns a BRAND NEW figure
    - Exactly ONE bar trace
    - No state, no accumulation
    """

    # --- guard: αν δεν έχουμε δεδομένα ---
    if df is None or df.empty or "timestamp" not in df.columns:
        now = datetime.now().strftime("%H:%M:%S")
        df = pd.DataFrame([[now, 0.0]], columns=["timestamp", "value"])

    # --- enforce schema & safety ---
    df = df.copy()
    df["value"] = pd.to_numeric(df["value"], errors="coerce").fillna(0.0)

    r = RANGES[metric]

    timestamps = df["timestamp"].astype(str).tolist()
    values = df["value"].astype(float).tolist()

    # ------------------------------------------------------------------
    # X-axis tick logic
    # ------------------------------------------------------------------
    tick_vals = []
    tick_text = []

    for i, ts in enumerate(timestamps):
        if i == 0:
            tick_vals.append(ts)
            tick_text.append(ts)                 # full HH:MM:SS
        elif ts.endswith(":00"):
            tick_vals.append(ts)
            tick_text.append(ts)                 # minute change
        else:
            tick_vals.append(ts)
            tick_text.append(ts[-2:])            # seconds only

    # ------------------------------------------------------------------
    # BUILD FIGURE (ONE TRACE ONLY)
    # ------------------------------------------------------------------
    fig = go.Figure()

    fig.add_trace(
        go.Bar(
            x=timestamps,
            y=values,
            marker=dict(
                color=values,
                colorscale=[
                    [0.0, "#2c7bb6"],   # blue
                    [0.5, "#abd9e9"],   # light blue
                    [0.75, "#fdae61"],  # orange
                    [1.0, "#d7191c"],   # red
                ],
                cmin=r["min"],
                cmax=r["max"],
                showscale=True,
                colorbar=dict(
                    orientation="h",
                    x=0.45,              # slightly left of center
                    xanchor="center",
                    y=-0.55,
                    len=0.75,
                ),
            ),
        )
    )

    # ------------------------------------------------------------------
    # LAYOUT
    # ------------------------------------------------------------------
    fig.update_layout(
        height=340,
        margin=dict(l=40, r=20, t=30, b=80),
        yaxis=dict(
            range=[r["min"], r["max"]],
            title=f"{metric.capitalize()} ({r['unit']})",
        ),
        xaxis=dict(
            title="Time",
            tickmode="array",
            tickvals=tick_vals,
            ticktext=tick_text,
        ),
        bargap=0.15,
        paper_bgcolor="#fafafa",
        plot_bgcolor="#fafafa",
        showlegend=False,
    )

    return fig

reset_csvs()
# ----------------------------------------------------------------------------- 
# Layout 
# ----------------------------------------------------------------------------- 
def layout_content():
    return html.Div(
        className="monitoring-tab",
        children=[
            html.Div(
            className="monitoring-tab",  # <<< Προστέθηκε wrapper class εδώ
            children=[
                # ---------------------------------------------------------------
                # KPI Section
                # ---------------------------------------------------------------
                html.H3("Monitoring & KPIs"),
                html.P(
                    "Single KPI demo block (Uptime) for testing.",
                    style={"color": "#444", "marginBottom": "10px"},
                ),
                html.Div(
                    [
                        html.Button("Generate KPI", id="mon-generate-btn", n_clicks=0),
                        html.Button(
                            "Open toolbox",
                            id="mon-open-toolbox",
                            n_clicks=0,
                            style={"marginLeft": "10px"},
                        ),
                        dcc.Checklist(
                            id="mon-show-chart",
                            options=[{"label": "Show chart", "value": "show"}],
                            value=[],
                            style={"display": "inline-block", "marginLeft": "20px"},
                        ),
                    ],
                    style={"marginBottom": "10px"},
                ),
                dcc.Graph(id="mon-uptime-indicator", style={"height": "120px"}),
    
                html.Div(
                    [dcc.Graph(id="mon-uptime-chart", style={"height": "300px"})],
                    id="mon-chart-wrap",
                    style={"display": "none"},
                ),
                dcc.Store(id="mon-popup-dummy"),
    
                html.Hr(style={"margin": "30px 0"}),
    
                # ---------------------------------------------------------------
                # UCY Cable Monitoring Section
                # ---------------------------------------------------------------
                html.H4("UCY Cable Monitoring", style={"marginBottom": "10px"}),
    
                # Ribbon Menu (nested submenus)
                html.Div(
                    className="ribbon-container",
                    children=[
                        # --- HOME TAB ---
                        html.Div(
                            className="ribbon-tab",
                            id="tab-home",
                            n_clicks=0,
                            children=[
                                "Home",
                                html.Div(
                                    id="submenu-home",
                                    className="submenu",
                                    children=[
                                        html.Div("New", className="menu-item"),
                                        html.Div("Save", className="menu-item"),
                                        html.Div("Open", className="menu-item"),
                                        html.Div("Exit", className="menu-item"),
                                    ],
                                ),
                            ],
                        ),
                        # --- DATA TAB ---
                        html.Div(
                            className="ribbon-tab",
                            id="tab-data",
                            n_clicks=0,
                            children=[
                                "Data",
                                html.Div(
                                    id="submenu-data",
                                    className="submenu",
                                    children=[
                                        html.Div("Import Data", className="menu-item", id="data-import"),
                                        html.Div("Export Data", className="menu-item"),
                                    ],
                                ),
                            ],
                        ),
                        # --- VIEW TAB ---
                        html.Div(
                            className="ribbon-tab",
                            id="tab-view",
                            n_clicks=0,
                            children=[
                                "View",
                                html.Div(
                                    id="submenu-view",
                                    className="submenu",
                                    children=[
                                        html.Div("Zoom In", className="menu-item"),
                                        html.Div("Zoom Out", className="menu-item"),
                                    ],
                                ),
                            ],
                        ),
                        # --- SETTINGS TAB ---
                        html.Div(
                            className="ribbon-tab",
                            id="tab-settings",
                            n_clicks=0,
                            children=[
                                "Settings",
                                html.Div(
                                    id="submenu-settings",
                                    className="submenu",
                                    children=[
                                        html.Div("PMU Settings", className="menu-item", id="settings-pmu"),
                                        html.Div("Display Options", className="menu-item"),
                                        html.Div("System Info", className="menu-item"),
                                    ],
                                ),
                            ],
                        ),
                        # --- PMU DROPDOWN ---
                        html.Div(
                            [
                                html.Label("Select PMU:", style={"marginRight": "6px"}),
                                dcc.Dropdown(
                                    id="ucy-pmu-select",
                                    options=[
                                        {"label": "PMU #1", "value": "pmu1"},
                                        {"label": "PMU #2", "value": "pmu2"},
                                    ],
                                    value="pmu1",
                                    clearable=False,
                                    style={"width": "150px"},
                                ),
                            ],
                            style={"marginLeft": "auto", "display": "flex", "alignItems": "center"},
                        ),
                    ],
                ),
    
                # Cable container (image-based)
                html.Div(
                    className="cable-container",
                    children=[
                        html.Img(src="/assets/pmu_left.png", className="pmu-icon left"),
                        html.Img(src="/assets/hvdc_line.png", className="cable-img"),
                        html.Img(src="/assets/pmu_right.png", className="pmu-icon right"),
                    ],
                ),
                # === REAL-TIME MONITORING BLOCK ===
                html.Div(
                    style={"margin": "20px 0"},
                    children=[
                        html.Div(
                            style={"display": "flex", "gap": "20px", "alignItems": "center"},
                            children=[
                                dcc.Dropdown(
                                    id="rt-metric",
                                    options=[
                                        {"label": "Load (A)", "value": "load"},
                                        {"label": "Temperature (°C)", "value": "temp"},
                                    ],
                                    value="load",
                                    clearable=False,
                                    style={"width": "220px"},
                                ),
                                dcc.Dropdown(
                                    id="rt-refresh",
                                    options=[
                                        {"label": "1 sec", "value": 1000},
                                        {"label": "2 sec", "value": 2000},
                                        {"label": "5 sec", "value": 5000},
                                    ],
                                    value=1000,
                                    clearable=False,
                                    style={"width": "160px"},
                                ),
                                html.Div(id="rt-clock", style={"fontWeight": "bold"}),
                            ],
                        ),
                
                        dcc.Graph(id="rt-graph"),
                
                        html.Div(
                            id="rt-minmax",
                            style={"marginTop": "8px", "color": "red"},
                        ),
                
                        dcc.Interval(id="rt-interval", interval=1000, n_intervals=0),
                    ],
                ),
                # === END REAL-TIME MONITORING BLOCK ===
                # PMU Info + Chart
                html.Div(
                    [
                        html.Div(
                            [
                                html.P(
                                    html.A(
                                        "PMU Coordinates: (34.700123, 33.312345)",
                                        id="pmu-coords-display",
                                        href="https://www.google.com/maps?q=34.700123,33.312345",
                                        target="_blank",
                                        style={"color": "#0044cc", "textDecoration": "none"},
                                    )
                                ),
                                html.P("Voltage Level: 132 kV"),
                                html.P("Current: 450 A"),
                                html.P("Frequency: 50 Hz"),
                            ],
                            className="pmu-info",
                        ),
                        html.Div(
                            [
                                html.Button("Generate / Refresh Data", id="ucy-gen-btn", n_clicks=0),
                                dcc.Graph(id="ucy-data-graph", style={"height": "320px", "marginTop": "10px"}),
                            ],
                            className="pmu-chart",
                        ),
                    ],
                    style={"padding": "10px"},
                ),
            ],
            style={"padding": "20px"},
        )],
        style={"padding": "20px"},
    )

def layout():
    return menu_layout()
# -----------------------------------------------------------------------------
# Callbacks
# -----------------------------------------------------------------------------
def register_callbacks(app):
    
    
    @app.callback(
        Output("rt-interval", "interval"),
        Input("rt-refresh", "value"),
    )
    def update_interval(val):
        return val

    @app.callback(
        [
            Output("rt-graph", "figure"),
            Output("rt-minmax", "children"),
            Output("rt-clock", "children"),
        ],
        Input("rt-interval", "n_intervals"),
        State("rt-metric", "value"),
        State("rt-refresh", "value"),
    )
    
    def update_realtime(_, metric, refresh_ms):
        # === LOAD ===
        df_load = load_data("load")
        prev_load = df_load["value"].iloc[-1] if not df_load.empty else None
    
        raw_load = generate_value("load")
        load_val = apply_rate_limit(prev_load, raw_load, 0.05)
        append_data("load", load_val)
    
        # === TEMP ===
        df_temp = load_data("temp")
        prev_temp = df_temp["value"].iloc[-1] if not df_temp.empty else None
    
        raw_temp = generate_temp_from_load(load_val)
        temp_val = apply_rate_limit(prev_temp, raw_temp, 0.02)
        append_data("temp", temp_val)
    
        # === DISPLAY ===
        window_sec = max(1, refresh_ms // 1000)
        df = load_data(metric, window_sec=window_sec)
        fig = build_figure(df, metric)
    
        r = RANGES[metric]
        minmax = f"Min {metric}: {r['min']} {r['unit']} | Max {metric}: {r['max']} {r['unit']}"
        clock = datetime.now().strftime("%H:%M:%S")
    
        return fig, minmax, clock
    # KPI chart visibility
    @app.callback(Output("mon-chart-wrap", "style"), Input("mon-show-chart", "value"))
    def toggle_chart(show_vals):
        return {"display": "block"} if "show" in show_vals else {"display": "none"}

    # Generate KPI & chart
    @app.callback(
        [Output("mon-uptime-indicator", "figure"),
         Output("mon-uptime-chart", "figure")],
        Input("mon-generate-btn", "n_clicks"),
    )
    def generate_kpi(n):
        df = _synth_series(days=7 if n else 30, freq_per_day=24)
        last_val = float(round(df["value"].iloc[-1], 2))
        return _indicator(last_val), _chart(df)

    # Synthetic PMU data chart
    @app.callback(Output("ucy-data-graph", "figure"),
                  Input("ucy-gen-btn", "n_clicks"))
    def ucy_generate_data(n):
        np.random.seed(None)
        x = np.arange(0, 100)
        y = np.random.normal(0, 1, 100).cumsum()
        fig = go.Figure(go.Scatter(x=x, y=y, mode="lines",
                                   line=dict(color="#555")))
        fig.update_layout(
            title="Synthetic PMU Data Stream (demo)",
            xaxis_title="Time index",
            yaxis_title="Value",
            paper_bgcolor="#fafafa",
            plot_bgcolor="#fafafa",
        )
        return fig

    # Toggle submenus visibility
    @app.callback(
        [Output("submenu-home", "style"),
         Output("submenu-data", "style"),
         Output("submenu-view", "style"),
         Output("submenu-settings", "style")],
        [Input("tab-home", "n_clicks"),
         Input("tab-data", "n_clicks"),
         Input("tab-view", "n_clicks"),
         Input("tab-settings", "n_clicks")],
    )
    def toggle_submenus(h, d, v, s):
        ctx = dash.callback_context
        if not ctx.triggered:
            return [{"display": "none"}] * 4
        tab = ctx.triggered[0]["prop_id"].split(".")[0]
        visible = {"display": "flex", "flexDirection": "column"}
        hidden = {"display": "none"}
        mapping = {"tab-home": 0, "tab-data": 1,
                   "tab-view": 2, "tab-settings": 3}
        styles = [hidden] * 4
        if tab in mapping:
            styles[mapping[tab]] = visible
        return styles

    # ---------------------------------------------------------
    # Client-side callbacks for external popups (Flask routes)
    # ---------------------------------------------------------

    # Open Toolbox
    app.clientside_callback(
        """
        function(n_clicks){
            if(!n_clicks) return null;
            window.open('/toolbox','ToolboxWindow',
                        'width=600,height=400,left=200,top=200,resizable=yes,scrollbars=yes');
            return 'opened';
        }
        """,
        Output("mon-popup-dummy", "data"),
        Input("mon-open-toolbox", "n_clicks"),
        prevent_initial_call=True,
    )

    # Import Data popup
    app.clientside_callback(
        """
        function(n_clicks){
            if(!n_clicks) return null;
            window.open('/import','ImportWindow',
                        'width=600,height=500,left=250,top=200,resizable=yes,scrollbars=yes');
            return 'opened';
        }
        """,
        Output("submenu-data", "title"),
        Input("data-import", "n_clicks"),
        prevent_initial_call=True,
    )

    # PMU Settings popup
    app.clientside_callback(
        """
        function(n_clicks){
            if(!n_clicks) return null;
            window.open('/coordinates','CoordWindow',
                        'width=500,height=400,left=280,top=220,resizable=yes,scrollbars=yes');
            return 'opened';
        }
        """,
        Output("submenu-settings", "title"),
        Input("settings-pmu", "n_clicks"),
        prevent_initial_call=True,
    )
    
    register_tab_menu_callbacks(app, TAB_PREFIX)

